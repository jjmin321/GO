//14-1

package main

import "fmt"

type Car struct {
	name  string
	color string
	price int64
	tax   int64
	//  Price func() 	//리시버 메소드 Price
}

//구조체 <-> 메소드 바인딩
func (c Car) Price() int64 { //만약 리시버 메소드 명이 Price가 아니라 price라면 에러가 난다.
	return c.price + c.tax
}

func main() {
	//GO -> 객체 지향 타입을 구조체로 정의한다. (클래스, 상속 개념 없음)
	//객체 지향 -> 클래스(속성 : 멤버변수, 기능(상태 : 메소드)) : 코드의 재사용성, 코드의 관리가 용이, 신뢰성이 높은 프로그래밍
	//클래스가 없는데 객체 지향 언어일까? -> 맞다
	//GO는 전형적인 객체지향의 특징을 가지고 있지 않지만, 인터페이스 -> 다형성 지원, 구조체 -> 클래스형태의 코딩 가능
	//객체지향의 기본 개념 -> GO에서 포함하고 있다. -> 객체 지향 프로그래밍 언어
	//상태, 메소드를 분리해서 정의(결합성 없음)
	//사용자 정의 타입 : 구조체, 인터페이스, 기본 타입(int, float, string...) , 함수
	//구조체와 -> 메소드 연결을 통해서 타 언어의 클래스 형식처럼 사용 가능하다 (객체지향이 맞다)
	//클래스는 구조체다. 구조체는 클래스가 아니다. 클래스는 구조체와 메소드의 연결과 같다.

	//ex1
	bmw := Car{"520d", "White", 500000000, 5000000}
	benz := Car{"264e", "Red", 600000000, 6000000}

	fmt.Println("bmw : ", bmw, &bmw)
	fmt.Println("benz : ", benz, &benz)
	fmt.Println("ex2 : ", bmw.Price())  //객체 지향
	fmt.Println("ex2 : ", benz.Price()) //객체 지향

	// Car타입의 이름, 색, 가격, 세금을 정의하고 Price라는 리시버 메소드(클래스)를 선언해서 차의 총 가격을 알 수 있게끔 하여 차이름.Price()를 사용하여 그 차의 가격을 알 수 있게 만든 객체지향 프로그램.
	// 객체지향을 사용해서 더 보기 쉽고 편하게 함. Price(bmw)는 Price함수가 돋보이지만 , bmw.Price()는 bmw의 가격을 알려주는 것이라고 확 보임.
	// 구조체를 이용하므로 재사용성이 매우 뛰어나고 어떤 기능을 가지고 있는지 쉽게 확인할 수 있음. 즉, 코드의 관리가 용이하고 신뢰성이 높은 것이 객체지향 프로그래밍임.
}
